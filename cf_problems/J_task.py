# опять начну с идеи,опять смотрим на зависимость между признаками
# но теперь чтобы не работать с выбросами смотрим не на данные а на место в посорченном списке
# потом просто смотрим на квадрат разности рангов для двух признаков и чем больше сумма тем меньше связь
# потом просто нормализуем и специально так подбираем коэфы тк если два набора максимально различны то у нас сумма (i - (n-i+1))^2
# а значит максимум суммы в n(n^2-1)/6 в итоге вычитаем дробь из 1 хтобы что 1 было в случае похожести, по-моему такой способ измерения связи самый естественный тк смотрим именно на то как расположены данные именно сточки зрения мест в списках и как места соотносятся
# в коде сделем через получение по массиву значений массив индексов где на i позиции будет индекс iого элемента из нашего в отсортированном массиве
# то есть при сортировке индексов через key говорим что смотрим по критерию того насколько большой ему соответствует элемент
# upd: мб проблема в том что не было добавления 1, хотя кажется они не должны влиять на разность...
n = int(input())
kateg1 = []
kateg2 = []

for _ in range(n):
    x, y = map(int, input().split())
    kateg1.append(x)
    kateg2.append(y)
sortedX = sorted(range(n), key=lambda i: kateg1[i])
sortedY = sorted(range(n), key=lambda j: kateg2[j])

rankX = [0] * n
rankY = [0] * n

for i in range(n):
    rankX[sortedX[i]] = i + 1

for i in range(n):
    rankY[sortedY[i]] = i + 1

total_sum = 0
for i in range(n):
    total_sum += (rankX[i] - rankY[i]) ** 2
spearman= 1 - (6 * total_sum) / (n * (n**2 - 1))
print(f"{spearman:.7f}")
